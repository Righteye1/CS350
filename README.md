This project focused on building a fully functional smart thermostat prototype using a Raspberry Pi, GPIO components, and Python. The thermostat was designed to read temperature data from an AHT20 sensor and control heating or cooling behavior using a state machine. It used LED indicators to reflect the current mode and allowed user input through physical buttons. System information was displayed on a 16 by 2 LCD screen, and updates on system status were sent over UART. The main goal was to simulate how a smart thermostat could manage environmental control based on real-time sensor input, while also laying the foundation for future cloud integration.

One area where I feel I performed well was in managing the logic behind the state machine. I structured the code to make transitions between heating, cooling, and idle states clear and efficient. The hardware responded smoothly to changes, and the integration between the physical components and software logic felt reliable and intuitive. I am also confident in how I handled display updates and formatted serial output to meet the technical requirements of the project.

One challenge I encountered was during the initial circuit setup. The breadboard layout I used differed slightly from the one shown in the instructions. This created some confusion and led to delays in troubleshooting unexpected hardware behavior. From that experience, I learned to pay closer attention to pin alignment and to adapt instructions more flexibly based on available hardware.

Throughout the project, I relied on several external resources that proved helpful. These included documentation from Adafruit, Raspberry Pi GPIO references, and Python threading tutorials. They helped me troubleshoot hardware interactions and manage concurrent tasks more effectively.

This experience strengthened several important skills, especially in integrating hardware and software, designing state machines, and processing real-time data. These abilities will be directly applicable in future projects related to embedded systems, connected devices, and systems programming.

To keep the code easy to maintain, I made sure to organize each function into a dedicated section. Sensor reading, state transitions, display updates, and serial communication are each handled in their own methods. I used descriptive variable and function names to make the code self-explanatory. I also included debug messages to assist with troubleshooting. As a result, the code can be modified easilyâ€”for example, to support more sensors or add new system behaviors in future iterations.
